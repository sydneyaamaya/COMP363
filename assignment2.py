# -*- coding: utf-8 -*-
"""Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Me7_zKrrynxsfEuuKIzuPb1JysJyZKG
"""

class Node:
    """Simple linkable node that can be used to build linked lists."""
    def __init__(self, value):
        """Constructor, creates a new node with the given value content and no
        next node assigned.
        """
        self.value = value
        self.next = None

    def set_next(self, next):
        """Sets the next node."""
        self.next = next

    def has_next(self):
        """Predicate accessor for next node; returns true is there is a next
        node; false otherwise.
        """
        return self.next is not None

    def get_next(self):
        """Accessor for next."""
        return self.next

    def __lt__(self, other):
        """Simple comparator, returns true if invoking object is less than
        referenced object.
        """
        return self.value < other.value

    def __str__(self):
        "String representation of the node"
        return f'{self.value}'


class Linked_List:
    """A simple linked list object with O(1) insertion thanks to its self.tail
    field.
    """
    def __init__(self):
        """Constructor; new linked list is always empty."""
        self.head = None
        self.tail = None
        self.size = 0

    def add(self, data):
        """Adds a new node at the end of the linked list."""
        # Check if data is actual node or not
        if not isinstance(data, Node):
            # It's not a node; make it a node
            data = Node(data)
        # At this point variable data is a node
        if self.head is None:
            self.head = data
        else:
            self.tail.set_next(data)
        self.tail = data
        self.size += 1

    def __str__(self):
        if self.head is None:
            return f"empty list"
        else:
            string = ""
            current = self.head
            while current is not None:
                string = string + str(current) + " "
                current = current.get_next()
            return f"{string}"

class MergeSortLL:
   '''
   method to split linked list in half
   use two pointers fast and slow
   when fast reaches the end of the linked list
   the slow pointer will be in the middle which
   is where the linked list should be split in half
   '''
   @staticmethod
   def splitLL(head):
     fast = head
     slow = head

     while (fast and fast.next):
       fast = fast.next.next
       if fast:
        slow = slow.next
     second = slow.next
     slow.next = None
     return second

   '''
   merge method sorts two arrays and merges them with
   all nodes in order of increasing values
   compare the values of first and second and call
   merge recursively depending on which list has the smaller
   value
   '''
   @staticmethod
   def merge(first, second):
     #check if both linked list are empty or have on node
     #that means they are already sorted
     if not first:
       return second
     if not second:
       return first
     #note to myself -- calling merge recursively is similar to
     #using a whule loop to append an array
     if first.value < second.value:
      first.next = MergeSortLL.merge(first.next, second)
      return first
     else:
       second.next = MergeSortLL.merge(first, second.next)
       return second

   '''
   dive and conquer method:
   mergseSort method calls splitLL to split linked list is half
   and calls itself recursively to repeatedly split in half until
   the linked list is sorted in single nodes and then calls merge
   to merge all nodes together in a sorted list
   '''
   @staticmethod
   def mergeSort(head):
    #check if list is empty or has one node
    if not head or not head.next:
     return head

    second = MergeSortLL.splitLL(head)

    head = MergeSortLL.mergeSort(head)
    second = MergeSortLL.mergeSort(second)

    return MergeSortLL.merge(head, second)

#testing

head = Node(100)
head.next = Node(-9)
head.next.next = Node(5)
head.next.next.next = Node(1)

head = MergeSortLL.mergeSort(head)
current = head

while current:
  print(current.value)
  current = current.next